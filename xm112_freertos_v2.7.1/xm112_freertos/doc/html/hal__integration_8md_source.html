<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Acconeer SDK: /home/ai/jenkins/workspace/sw-main/doc/user_guides/rss/hal_integration.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 66px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hal__integration_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/ai/jenkins/workspace/sw-main/doc/user_guides/rss/hal_integration.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="hal__integration_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# HAL Software Integration {#hal_integration}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;## Introduction</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;This document aims to provide help and support for customers that wish to integrate A111 towards an MCU or processor that is not included in Acconeer&#39;s module offering. This document covers the software needed to integrate Acconeer’s libraries with MCU specific drivers. Hardware integration is covered in the document “Hardware and physical integration guideline PCR Sensor A111” that is available for download at the [developer site](http://developer.acconeer.com).</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;The A111 pulse coherent radar sensor is dependent on a software stack running on a host MCU. The host software handles low-level configuration of the radar sensor and pre-processing of radar data. All low-level sensor configurations are uploaded to the sensor at startup, meaning that no firmware or configuration parameters are stored in the sensor permanently.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;The number of potential MCU and processors, including variants, that users of A111 may want to use in their products are bordering to endless. Acconeer will not be able to support fully integrated software for all of them but have selected a few MCUs that every SW release are verified against. Some of them have also been included in different versions of our EVKs or modules.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;## Acconeer EVK and Modules</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;Acconeer has designed EVKs and Modules based on the following MCU/Processors. All of which can be bought on [Digi-Key](www.digikey.com).</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* Raspberry Pi 3, 3+ and 4: Our standard EVK (XC/XR112), running Raspbian.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;* Atmel ATSAME70Q21A-AN: An ARM Cortex M7 MCU that we have chosen to use in our high performance module XM112.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;* Nordic Semiconductors nRF52840: An ARM Cortex M4 MCU that is featured in our IoT module XM122, designed for Low Cost and Low Power.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;Documentation, including schematics and BOM, for above HW is available from Acconeer web site.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;## Acconeer Software Delivery</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;Acconeer provides software deliveries to the EVKs and Modules on our [developer site](http://developer.acconeer.com). It contains example programs and fully implemented HAL for respective hardware for an easy start of development.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;Acconeer also provides an SDK for ARM Cortex M4 and M7 based MCUs. The SDK contains the libraries for respective MCU and example programs to show how to use the different services in Radar System Software (RSS). Acconeer also provides a reference implementation of the Hardware Abstraction Layer (HAL) for MCUs from ST Microelectronics and this implementation can be used for a quick start with STM32CubeIDE.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Instructions on how to integrate STM32 MCUs from ST Microelectronics and set up a project in STM32CubeIDE can be found on the [developer site](http://developer.acconeer.com). For other ARM Cortex M4 and M7 based MCUs a Hardware Abstraction Layer (HAL) integration must be written according to the guidelines in this document.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;## HW Integration Overview</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;Hardware integration is covered in the document “Hardware and physical integration guideline PCR Sensor A111” that is available for download at the [developer site](http://developer.acconeer.com). The purpose of this section is only to define the pin names and connections necessary for the software integration.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;![Pin names and connections between A111 and MCU](mcu_integration.png)</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;### GPIO Control Signals</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;The Acconeer Sensor SW package uses two GPIO control signals A111_ENABLE and A111_INTERRUPT. A111_ENABLE signal is used to turn the A111 sensor on and off. The A111_ENABLE signal is active high. The A111_INTERRUPT signal is used to signal the host MCU that the internal buffer memory contains new measurement data ready to be transferred via the SPI interface. The A111_INTERRUPT signal is active high.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;### SPI Bus</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;The A111 communicates with the host MCU via a 4-line SPI interface. The maximum supported SPI clock frequency is 50MHz. The A111 is an SPI slave device. The SPI signals are named A111_SPI_CLK, A111_SPI_MOSI, A111_SPI_MISO, and A111_SPI_SS_N. Note that the slave select signal, A111_SPI_SS_N, is active low and often controlled by a GPIO on the MCU.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;### Power Control</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;Some hardware designs include a Power Management Unit (PMU) or a power switch that allows the MCU to completely shut off the power to the A111 sensor. In examples for software integration we use a GPIO pin with the name SENSOR_PMU_ENABLE to control the power to the radar sensor.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;### Crystal</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;The A111 radar sensor needs a crystal or an external clock source for clock reference. The frequency of the crystal has to be specified in the HAL integration.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;## Prototype Integrations</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;For prototype integrations with an MCU development board we recommend using the “SparkFun Pulsed Radar Breakout - A111”. It is a breakout board with an A111 radar sensor, crystal and a level shifter that makes it easy to connect the A111 to an MCU board with I/O-pins that operates at 3.3V. Note that some Sparkfun breakout boards have the Vcc pin labeled 5V. This pin should be connected to 3.3V if you have an MCU with 3.3V logic on the I/O pins.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;## Software Integration</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;The Acconeer software delivery consists of an SDK with pre-compiled RSS libraries, headers and example programs to show how to use the different services and detectors.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;![Overview of Radar System Software](RSS-overview.png)</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;Radar System Software (RSS) is the software that will help you interact with the A111 radar sensor. To properly function, this software utilizes MCU specific functions to handle memory and communication with the sensor. Each integration of the sensor to a hardware requires a specific pin configuration and different drivers from the MCU. This is solved by a user-written Hardware Abstraction Layer (HAL). The HAL is a glue layer between RSS and the MCU drivers.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;RSS must be activated before it is used, and a HAL struct is passed as an argument to the function acc_rss_activate. The HAL struct contains properties and function pointers that RSS use in its communication with the hardware. The HAL struct and the function pointer types are declared in the header file acc_hal_definitions.h.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;Acconeer provide fully verified implementations of a HAL for our EVKs and Modules in the respective software deliveries. Reference implementations are also provided for STM32 MCUs in the Cortex M4 and Cortex M7 packages, see for example the file acc_hal_integration_single_thread_stm32cube_sparkfun_a111.c</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;The following sub-chapters describe how to set the properties and write the functions that are included in the HAL struct.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;### The sensor_count Property</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;The sensor count is the maximal sensor ID that the integration layer supports and must not exceed ACC_SENSOR_ID_MAX.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;### The max_spi_transfer_size Property</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;The max_spi_transfer_size should be set to the maximum buffer size that can be transferred over the SPI bus. If there is no restriction, the limit should be set to SIZE_MAX.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;### Power-on Function</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;The power-on function is called when the sensor needs to be enabled. It takes sensor_id as an argument and it returns void. The power to the A111 sensor is preferably turned on and A111_SPI_SS_N set to high before creating the service, but can optionally be done here.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;The function should do the following:</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;* Prerequisite: The sensor is powered on and A111_SPI_SS_N is set to high</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;* Set A111_ENABLE High</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;* Wait 2 ms for sensor crystal to stabilize</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;* Clear pending interrupts</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;### Power-off Function</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;The power-off function is called when the sensor should be disabled. The power to the A111 sensor is preferably turned off and A111_SPI_SS_N set to low after destroying the service, but can optionally be done here.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;The function should do the following:</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;* Set A111_ENABLE Low</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;* Optional: The sensor is powered off and A111_SPI_SS_N is set to low</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;### Hibernate-enter Function</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;The hibernate-enter function shall be implemented if the application wants to use the power save mode hibernate. A prerequisite is that the GPIO CTRL is connected on the sensor.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;![Timing diagram of CTRL signal to enter Hibernate state](enter_hibernate_state.png)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;The function should do the following:</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;* GPIO CTRL should be set and cleared ACC_NBR_CLOCK_CYCLES_REQUIRED_HIBERNATE_ENTER number of times.</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;* Optional power save by disabling VIO_1 and VIO_2: required time before disable VIO_1 and VIO_2 after entering Hibernate, t1: 0 ns. If this is done, make sure that VIO_1 and VIO_2 are enabled again in the Power-on Function.</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;XM122 supports power save mode hibernate and can be used as a reference on how to implement the hibernate HAL functions.</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;### Hibernate-exit Function</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;The hibernate-exit function shall be implemented if the application wants to use the power save mode hibernate. A prerequisite is that the GPIO CTRL is connected on the sensor.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;![Timing diagram of CTRL signal to exit Hibernate state](exit_hibernate_state.png)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;The function should do the following:</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;* Optional power save by disabling VIO_1 and VIO_2: required time after disable VIO_1 and VIO_2 before exit Hibernate, t2: 0 ns</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;* GPIO CTRL should be set and cleared ACC_NBR_CLOCK_CYCLES_REQUIRED_STEP_1_HIBERNATE_EXIT number of times.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;* sleep ACC_WAIT_TIME_HIBERNATE_EXIT_MS, t3: 2 ms (absolute waiting time depends on crystal and tuning capacitor)</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;* GPIO CTRL should be set and cleared ACC_NBR_CLOCK_CYCLES_REQUIRED_STEP_2_HIBERNATE_EXIT number of times.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;XM122 supports power save mode hibernate and can be used as a reference on how to implement the hibernate HAL functions.</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;### Sensor Transfer Function</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;The sensor transfer function is called by RSS to transfer data to and from the radar sensor over the SPI bus. The maximum buffer size can be limited by setting the property max_spi_transfer_size in the HAL struct. The buffer size is always a multiple of two and the buffer is guaranteed to be 16 bit aligned even though the transfer function is defined with an 8-bit array. It is beneficial from performance perspective to utilize DMA if available and as big buffer transfer size as possible.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;The function should do the following:</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;* Set A111_SPI_SS_N Low</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;* Send and receive SPI buffer</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;* Set A111_SPI_SS_N High</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;### Wait for Interrupt Function</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;This function shall wait at most timeout_ms for the interrupt to become active and then return true. It may return true immediately if an interrupt has occurred since last call to this function. If a timeout occurred and the function waited more than timeout_ms for the interrupt to become active it shall return false.</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;A simple and portable way of implementing the wait for interrupt function is to use polling. The function should then repeatedly do the following until the interrupt pin is high or a timeout has occurred:</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;* Check the A111_INTERUPT pin and return true if interrupt pin is HIGH</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;* Sleep a short time</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;* Return false if timeout</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;* Start over and check the interrupt pin again.</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;While polling is great for maximum portability an optimized implementation may take advantage of HW interrupt support in the MCU to reduce latency and power consumption.</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;### Mem-alloc function</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;Return pointer to memory, NULL is seen as failure. Allocated memory should be naturally aligned.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;### Mem-free function</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;Free memory which is previously allocated.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;### Get Time Function</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;The get time function should return the current time in milliseconds. The value is primarily used in log messages and does not have to return the correct wall clock time. Many implementations return the number of milliseconds since power-on of the MCU.</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;### Log Function</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;The purpose of the log function is to format log messages and to print them to e.g. the console or debug UART.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;The function below shows an example of how the log formatting can be implemented:</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;```c</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;#define LOG_BUFFER_MAX_SIZE 150</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;#define LOG_FORMAT &quot;%02u:%02u:%02u.%03u (%c) (%s): %s\n&quot;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;void acc_hal_integration_log(acc_log_level_t level, const char *module, const char *format, ...)</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;{</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;   char    log_buffer[LOG_BUFFER_MAX_SIZE];</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;   va_list ap;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;   va_start(ap, format);</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;   int ret = vsnprintf(log_buffer, LOG_BUFFER_MAX_SIZE, format, ap);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;   if (ret &gt;= LOG_BUFFER_MAX_SIZE)</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;   {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;           log_buffer[LOG_BUFFER_MAX_SIZE - 4] = &#39;.&#39;;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;           log_buffer[LOG_BUFFER_MAX_SIZE - 3] = &#39;.&#39;;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;           log_buffer[LOG_BUFFER_MAX_SIZE - 2] = &#39;.&#39;;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;           log_buffer[LOG_BUFFER_MAX_SIZE - 1] = 0;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;   }</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;   uint32_t time_ms = acc_hal_integration_get_current_time();</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;   char     level_ch;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;   unsigned int timestamp    = time_ms;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;   unsigned int hours        = timestamp / 1000 / 60 / 60;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;   unsigned int minutes      = timestamp / 1000 / 60 % 60;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;   unsigned int seconds      = timestamp / 1000 % 60;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;   unsigned int milliseconds = timestamp % 1000;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;   level_ch = (level &lt;= ACC_LOG_LEVEL_DEBUG) ? &quot;EWIVD&quot;[level] : &#39;?&#39;;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;   printf(LOG_FORMAT, hours, minutes, seconds, milliseconds, level_ch, module, log_buffer);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;   va_end(ap);</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;}</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;```</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;### Log Level Configuration</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;The log.log_level property should be set in the HAL struct to restrict the number of log messages generated by RSS.</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;Supported log levels:</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;```c</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;typedef enum</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;{</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;   ACC_LOG_LEVEL_ERROR,</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;   ACC_LOG_LEVEL_WARNING,</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   ACC_LOG_LEVEL_INFO,</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;   ACC_LOG_LEVEL_VERBOSE,</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;   ACC_LOG_LEVEL_DEBUG</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;} acc_log_level_enum_t;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;```</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;## References, List of Documentation</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;* Hardware and physical integration guideline PCR Sensor A111</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;* Integration using STM32CubeIDE</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;All Documents referred to can be found on the [developer site](http://developer.acconeer.com).</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
